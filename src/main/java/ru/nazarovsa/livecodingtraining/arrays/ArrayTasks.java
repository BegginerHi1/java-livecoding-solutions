package ru.nazarovsa.livecodingtraining.arrays;

import java.util.List;

/**
 * Задачи для работы с массивами
 */
public class ArrayTasks {

    /**
     * Задача 25.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * Метод принимает массив целых чисел. Необходимо переместить нули в конец массива, сохранив порядок сортировки.
     * [1, 2, 0, 1, 0, 1, 0, 3, 0, 1] -> [1, 2, 1, 1, 3, 1, 0, 0, 0, 0]
     */
    public static int[] moveZeroes(int[] arr) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 26.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * Дан массив, содержащий n различных чисел от 0 до n включительно, но одно число пропущено.
     * Найти это пропущенное число.
     * <p>
     * Ограничения:
     * - n >= 1
     * - Массив содержит только уникальные числа
     * - Числа находятся в диапазоне [0, n]
     * - Длина массива = n (так как одно число пропущено)
     * <p>
     * Примеры:
     * [3,0,1] -> 2 (пропущено число 2 в последовательности 0,1,2,3)
     * [0,1] -> 2 (пропущено число 2 в последовательности 0,1,2)
     * [9,6,4,2,3,5,7,0,1] -> 8 (пропущено число 8 в последовательности 0,1,2,3,4,5,6,7,8,9)
     * [1] -> 0 (пропущено число 0 в последовательности 0,1)
     */
    public static int findMissingNumber(int[] nums) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 27.
     * Задача: Монотонность массива
     * Массив называется монотонным, если он либо монотонно возрастающий, либо монотонно убывающий.
     * Массив A монотонно возрастающий если A[i] <= A[i+1] для всех i.
     * Массив A монотонно убывающий если A[i] >= A[i+1] для всех i.
     * Верните true если данный массив монотонный.
     * <p>
     * Примеры:
     * [1,2,2,3] => true (монотонно возрастающий)
     * [6,5,4,4] => true (монотонно убывающий)
     * [1,3,2] => false (не монотонный)
     * [1,2,4,5] => true (монотонно возрастающий)
     * [1,1,1] => true (и возрастающий, и убывающий)
     */
    public static boolean isMonotonic(int[] arr) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 28.
     * Найти пересечение двух массивов
     * Метод принимает два массива целых чисел и возвращает массив с элементами,
     * которые присутствуют в обоих массивах. Каждый элемент в результате должен
     * быть уникальным (без дубликатов).
     * <p>
     * Примеры:
     * [1,2,2,1], [2,2] -> [2] (число 2 присутствует в обоих массивах)
     * [4,9,5], [9,4,9,8,4] -> [4,9] или [9,4] (числа 4 и 9 присутствуют в обоих)
     * [1,2,3], [4,5,6] -> [] (нет общих элементов)
     * [1,1,1], [1,1] -> [1] (число 1 присутствует в обоих, но возвращается только один раз)
     * [], [1,2,3] -> [] (один из массивов пустой)
     * [7], [7] -> [7] (одинаковые массивы из одного элемента)
     */
    public static int[] intersection(int[] nums1, int[] nums2) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 29.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * Не пустой массив a длины n называется массивом всех возможностей, если он содержит все числа от 0 до a.length - 1 (оба включительно).
     * Реализуйте метод, который принимает массив и возвращает true, если массив является массивом всех возможностей, иначе false.
     * Например, [1,2,0,3] => True, [0,1,2,2,3] => False, [0] => True
     */
    public static boolean isAllPossibilities(int[] arr) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 30.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * На вход поступает несортированный список уникальных чисел. Необходимо вернуть список в котором за первым максимальным значением будет следовать первое минимальное, за вторым - второе и так далее.
     * Например: [15,11,10,7,12] -> [15,7,12,10,11]
     */
    public static List<Integer> maxMinArray(List<Integer> arr) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 31.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * Метод принимает массив чисел больше или равных нулю. Возвращает строку, содержащую максимальное число, которое можно собрать из элементов массива.
     * [1, 2, 3] --> "321" (3-2-1)
     * [3, 30, 34, 5, 9] --> "9534330" (9-5-34-3-30)
     */
    public static String biggest(int[] numbers) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 32.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * На вход поступает массив положительных чисел.
     * Метод должен вернуть минимальное положительное число, которое нужно добавить к сумме элементов чтобы сумма стала простым числом.
     * - Массив всегда содержит хотя бы 2 элемента.
     * - Все элементы положительные (n > 0)
     * - Массив может содержать дубликаты.
     * Простое число - это число, которое делится без остатка только на 1 и на само себя.
     */
    public static int minimumToPrime(int[] numbers) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 33.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * Дан отсортированный по возрастанию массив целых чисел numbers.
     * Необходимо найти два числа, сумма которых равна заданному значению target.
     * Вернуть индексы этих чисел.
     * Существует ровно одно решение в массиве
     * Ограничение сложности алгоритма O(n)
     */
    public static int[] twoSum(int[] numbers, int target) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 34.
     * ИСПОЛЬЗОВАНО НА СОЗВОНЕ
     * На вход поступает массив целых чисел.
     * Необходимо найти индекс, при котором сумма чисел слева и справа равны.
     * Если массив пустой или такого индекса нет, то вернуть -1.
     * {1, 2, 3, 4, 3, 2, 1} -> 3, элемент на третьей позиции "4". 1 + 2 + 3 слева равно 3 + 2 + 1 справа.
     * {1, 100, 50, -51, 1, 1} -> 1, 1 слева равно 50 + -51 + 1 + 1
     * {20, 10, -80, 10, 10, 15, 35} -> 0, 0 слева равно 10 + -80 + 10 + 10 + 15 + 35
     */
    public static int findEvenIndex(int[] arr) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 35.
     * Метод принимает массив интервалов в виде массива пар [start, end], где каждый интервал отсортирован (start ≤ end).
     * Необходимо объединить все перекрывающиеся интервалы и вернуть массив непересекающихся интервалов.
     * Вернуть пустой массив, если входные интервалы отсутствуют.
     * <p>
     * Два интервала [a, b] и [c, d] считаются перекрывающимися, если b >= c.
     * <p>
     * Примеры:
     * [[1,3], [2,6], [8,10], [15,18]] -> [[1,6], [8,10], [15,18]]
     * Интервалы [1,3] и [2,6] перекрываются, поэтому они объединяются в [1,6].
     * <p>
     * [[1,4], [4,5]] -> [[1,5]]
     * Интервалы [1,4] и [4,5] перекрываются на границе, поэтому они объединяются в [1,5].
     * <p>
     * [[1,4], [5,6]] -> [[1,4], [5,6]]
     * Интервалы [1,4] и [5,6] не перекрываются, поэтому они остаются отдельными.
     * <p>
     * [[1,4], [2,3]] -> [[1,4]]
     * Интервал [2,3] полностью содержится в [1,4], поэтому результатом будет [1,4].
     */
    public static int[][] mergeIntervals(int[][] intervals) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 36.
     * Сжимает массив по правилу: если подряд идут 3 или более одинаковых числа,
     * заменяет их на одно такое число. Остальные числа оставляет без изменений.
     * <p>
     * Примеры:
     * [1,1,1,2,3,3,4,4,4,4] -> [1,2,3,3,4] (три единицы становятся одной, четыре четверки становятся одной)
     * [5,5,2,2,2,2,2,1] -> [5,5,2,1] (пять двоек становятся одной двойкой)
     * [1,2,3] -> [1,2,3] (нет групп из 3+ элементов)
     * [7,7,7] -> [7] (три семерки становятся одной)
     * [1,1,2,2,2,3,3] -> [1,1,2,3,3] (только группа из трех двоек сжимается)
     * [] -> [] (пустой массив)
     * [5] -> [5] (один элемент)
     * [1,1,1,1,1,1] -> [1] (шесть единиц становятся одной)
     */
    public static int[] compressByMajority(int[] numbers) {
        throw new UnsupportedOperationException("Метод не реализован");
    }

    /**
     * Задача 37.
     * Задача: Группировка одинаковых элементов
     * Дан массив целых чисел. Необходимо переместить все одинаковые элементы вместе,
     * сохраняя их относительный порядок. Порядок групп должен соответствовать первому
     * появлению элемента в исходном массиве.
     * <p>
     * Примеры:
     * [1,2,1,3,2,1] => [1,1,1,2,2,3] (все 1 вместе, все 2 вместе, затем 3)
     * [4,4,2,1,2] => [4,4,2,2,1] (сначала группа 4, затем группа 2, затем 1)
     * [1,2,3] => [1,2,3] (все элементы уникальны)
     * [5,5,5] => [5,5,5] (все элементы одинаковы)
     * [] => [] (пустой массив)
     */
    public static int[] groupSameElements(int[] nums) {
        throw new UnsupportedOperationException("Метод не реализован");
    }
}
